package fhj.shelf.ui;

import java.awt.HeadlessException;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.Map;
import java.util.StringTokenizer;
import java.util.TreeMap;
import java.util.Map.Entry;
import java.util.concurrent.ExecutionException;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.JTextField;
import javax.swing.ListSelectionModel;
import javax.swing.ScrollPaneConstants;
import javax.swing.SwingWorker;
import javax.swing.table.DefaultTableModel;

import fhj.shelf.actionwindow.GetActionWindow;
import fhj.shelf.actionwindowfactory.GetActionWindowFactory;
import fhj.shelf.factorys.CommandFactory;
import fhj.shelf.factorys.CommandGetFactoryWithParameters;

import java.awt.SystemColor;


/**
 * 
 * Class whose instance gives a User Interface Representation of the domain
 * Class {@code GetOneShelf()}
 *
 * @author Filipa Estiveira, Hugo Leal, José Oliveira
 */
@SuppressWarnings("serial")
public class SearchShelf extends JFrame implements GetActionWindow{

	/**
	 * 
	 * Class that a single instance of SearchShelf class. Implements
	 * GetActionWindowFactory  and returns a GetActionWindow 
	 *
	 */
	public static class Factory implements GetActionWindowFactory {

		/**
		 * This is the constructor for the class above, it defines the factory
		 * 
		 */
		public Factory() {

		}

		/**
		 * This is an override method of the base class, it returns a new
		 * instance of SearchShelf
		 */
		
		@Override
		public GetActionWindow newInstance( Map<String, CommandFactory> mapCommands) {
			return new SearchShelf(mapCommands);
		}
	}

	private static final int LOCATION_Y = 100;
	private static final int LOCATION_X = 100;

	Map<String, CommandFactory> shelfCommands;
	private JTable jtShelfContents;
	private JScrollPane jspShelfContents;
	private JButton btnShelfdetails;
	private JTextField tfInputId;

	/**
	 * Constructor
	 * 
	 * @param shelfCommands
	 */
	public SearchShelf(Map<String, CommandFactory> shelfCommands) {
		getContentPane().setBackground(SystemColor.inactiveCaption);
		this.shelfCommands = shelfCommands;
		

		btnShelfdetails = new JButton("ShelfListElements");
		btnShelfdetails.setBounds(166, 11, 115, 23);
		
		createContentTable();
		// Sets window properties
		setTitle("Shelfs Details");
		setSize(499, 510);
		setLocation(LOCATION_X, LOCATION_Y);
		setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
		setVisible(true);
		getContentPane().setLayout(null);
		getContentPane().add(btnShelfdetails);
		
		tfInputId = new JTextField();
		tfInputId.setBounds(258, 45, 23, 23);
		getContentPane().add(tfInputId);
		tfInputId.setColumns(10);
		getContentPane().add(jspShelfContents);
		
		JLabel lblChooseShelfid = new JLabel("Choose Shelf_id");
		lblChooseShelfid.setBounds(166, 45, 99, 22);
		getContentPane().add(lblChooseShelfid);

		
		
		

		/*
		 * ActionListener listener registration in the button Search and button
		 * Delete.          When an event is generated by this component, is
		 *          created an instance of the inner class EventShelfSearch()
		 * and EventShelfDelete()
		 */
		btnShelfdetails.addActionListener(new EventShelfSearch());
//		btnDelete.addActionListener(new EventShelfDelete());

	}
	
	private JTable createContentTable() {

		jtShelfContents = new JTable(new DefaultTableModel(
			new Object[][] {
				{null, null, null, null, null},
				{null, null, null, null, null},
				{null, null, null, null, null},
				{null, null, null, null, null},
				{null, null, null, null, null},
				{null, null, null, null, null},
				{null, null, null, null, null},
				{null, null, null, null, null},
				{null, null, null, null, null},
				{null, null, null, null, null},
				{null, null, null, null, null},
				{null, null, null, null, null},
				{null, null, null, null, null},
				{null, null, null, null, null},
				{null, null, null, null, null},
				{null, null, null, null, null},
				{null, null, null, null, null},
				{null, null, null, null, null},
				{null, null, null, null, null},
				{null, null, null, null, null},
				{null, null, null, null, null},
				{null, null, null, null, null},
				{null, null, null, null, null},
				{null, null, null, null, null},
				{null, null, null, null, null},
				{null, null, null, null, null},
			},
			new String[] {
				"eid", "TypeElement", "Title", "IsAvailable","Collection"
			}
		));

		jspShelfContents = new JScrollPane(jtShelfContents);
		jspShelfContents.setBounds(10, 69, 469, 427);
		jspShelfContents
				.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);

		jtShelfContents.setCellSelectionEnabled(true);
		
		/**
		 *  Prevents the selection of more than one table row simultaneously
		 */
		jtShelfContents.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		return jtShelfContents;
	}
	
	/**
	 * Inner Class that implements ActionListener Interface, and invoke
	 * actionPerformed method for Search Button. The action is made in an
	 * Background Thread, by run SwingWorker framework by execute a
	 * EventHandling() object.
	 */
	private class EventShelfSearch implements ActionListener {

		@Override
		public void actionPerformed(ActionEvent e) {

			if (tfInputId.getText().equals("")) {
				JOptionPane.showMessageDialog(null, "You must put Shelf_id !");
				cleanFields();
			} else {
				Map<String, String> params = new TreeMap<String, String>();
				params.put("id", tfInputId.getText());
				
				new EventHandling(params).execute();
			}

		}

	}

	/**
	 * Inner Class call in the actionPerformed method
	 * 
	 * @author Filipa Estiveira, Hugo Leal, José Oliveira
	 */
	private class EventHandling extends SwingWorker<Map<String, String>, Void> {
		Map<String, String> params;
		
		
		public EventHandling(Map<String, String> map) {
			this.params = map;
				}
		
		
		@Override
		protected Map<String, String>  doInBackground() throws Exception {

			CommandGetFactoryWithParameters getShelf = (CommandGetFactoryWithParameters) shelfCommands.get("getShelf");
			return getShelf.newInstance(params).execute();
		}

		@SuppressWarnings("unused")
		@Override
		protected void done() {

			try {
				Map<String, String> map = new TreeMap<String, String>();
//			
				int i= 0;
				int j =1;
				for (Entry<String, String> element : ((Map<String, String>) get()).entrySet()) 
				{
			
					// Fill the cells in the empty line. The numbering of the
					// columns starts at 0
					
				
					
					jtShelfContents.setValueAt(createMapParametersReaders(map, get().get("Element_id_"+j)).get("eid"), i, 0);
					jtShelfContents.setValueAt(createMapParametersReaders(map, get().get("Element_id_"+j)).get("type"), i, 1);
					jtShelfContents.setValueAt(createMapParametersReaders(map, get().get("Element_id_"+j)).get("title"), i, 2);
					jtShelfContents.setValueAt(createMapParametersReaders(map, get().get("Element_id_"+j)).get("IsAvailable"), i, 3);
//					jtShelfContents.setValueAt(createMapParametersReaders(map, get().get("Element_id_"+j)).get("name"), i, 4);
                    j++;
					i++;
				}
		
			} catch (HeadlessException e) {
				Logger.getLogger(SearchShelf.class.getName()).log(Level.WARNING, " HeadlessException Occured : ", e);
				
			} catch (InterruptedException e) {
				Logger.getLogger(SearchShelf.class.getName()).log(Level.WARNING, " InterruptedException Occured : ", e);
			} catch (ExecutionException e) {
				Logger.getLogger(SearchShelf.class.getName()).log(Level.WARNING, " ExecutionExceptionn Occured : ", e);
			} catch (NullPointerException e) {
				
				JOptionPane.showMessageDialog(null, "Shelf doesn´t exist" + e);
				cleanFields();
				Logger.getLogger(SearchShelf.class.getName()).log(Level.WARNING, " NullPointerException Occured : ", e);
			} catch (Exception e) {
				
				Logger.getLogger(SearchShelf.class.getName()).log(Level.WARNING, " Exception Occured : ", e);
			}

		}
	}
	
	
	private static Map<String, String> createMapParametersReaders(
			Map<String, String> mapParameters, String resp) throws Exception {
		
		StringTokenizer ValueTokenizer = new StringTokenizer(resp, "&");
		
		while (ValueTokenizer.hasMoreElements()) {
			String v =  ValueTokenizer.nextToken();
			StringTokenizer e = new StringTokenizer(v, "=");
			if ( e.countTokens() != 2 ) {
				throw new Exception("Unexpeced format value");
			}
			String key = e.nextToken();
			String value = e.nextToken();
			
			mapParameters.put(key, value);
						
		}
		
		return mapParameters;
	}
	
	

	@SuppressWarnings("unused")
	private class EventShelfDelete implements ActionListener {

		@Override
		public void actionPerformed(ActionEvent e) {

			if (tfInputId.getText().equals(null)) {
				JOptionPane.showMessageDialog(null, "You must searchFirst");
				cleanFields();
			} else {
			
				Map<String, String> params = new TreeMap<String, String>();
				params.put("id", tfInputId.getText());
				new EventHandlingDelete(params).execute();
			}

		}

	}

	private class EventHandlingDelete extends SwingWorker<Object, Void> {
		Map<String, String> params;
		
		String path;
		boolean modeStandAlone = false;
		public EventHandlingDelete(Map<String, String> map) {
			this.params = map;
		
		}
		
		
		@Override
		protected Object doInBackground() throws Exception {
			return modeStandAlone;

	
		}

		@Override
		protected void done() {

			try {
				JOptionPane.showMessageDialog(null,
						"Delete Shelf " + get());
			} catch (HeadlessException | InterruptedException
					| ExecutionException e) {

				Logger.getLogger(SearchShelf.class.getName()).log(Level.WARNING, " HeadlessException | InterruptedException"+
					"| ExecutionException Occured : ", e);
			}
			cleanFields();

		}
	}

	/**
	 * Method to clean all fields in JTextField
	 */
	private void cleanFields() {
		tfInputId.setText("");
		

	}
}
